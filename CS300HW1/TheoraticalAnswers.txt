CS 300 Homework 1 – Theoretical Answers
1. Why Queue & Stack?
A queue for orders matches real life—customers line up and get served in turn (FIFO). For finished drinks, a stack is close enough: baristas often leave cups in a little pile and grab the top one next. It isn’t perfect, but it works for our simulation.

2. Operation Costs
MenuList (singly linked):

addDrink(): O(1) (tail pointer).

removeDrink(code): O(n) scan.

swapDrinks(c1,c2): O(n) to find both then swap.

featureDrink(code): O(n) to locate and move.

findDrink(code): O(n) linear search.

printAll(): O(n) traverse.

size(): O(1).

OrderQueue (FIFO):

enqueue(): O(1).

dequeue(): O(1).

rushOrder(id): O(n) to find and splice.

cancelOrder(id): O(n) to find and remove.

empty(), size(): O(1).

traverse(): O(n).

PreparedStack (LIFO):

push(), pop(): O(1).

empty(), size(): O(1).

3. Mid-Queue Operations
rushOrder() and cancelOrder() dig into the middle of the queue, so they go beyond simple enqueue/dequeue (which are O(1)). A pure queue only adds at the back and removes at the front. Occasional mid-queue tweaks in O(n) are acceptable here, but if they were frequent, a different structure would be better.